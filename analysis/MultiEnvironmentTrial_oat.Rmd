---
title: "MultiEnvironmentTrial_oat"
author: "Leah Treffer"
date: "2026-01-24"
output: html_document
---


```{r libraries, include=FALSE}
library(here)
library(tidyverse)
library(rrBLUP)
library(ggplot2)
source(here::here("code", "setupMegaLMMstate.R"))
```

`MegaLMM` is installed from GitHub:

```{r}
if(!require(devtools)) { install.packages("devtools"); library(devtools) }
if(!require(MegaLMM)) { 
  devtools::install_github('deruncie/MegaLMM')
  library(MegaLMM) 
  }
```

```{r eval=FALSE, include=FALSE}
# devtools::install_github('deruncie/MegaLMM') # uncomment if needed to install. Install devtools first if needed with install.packages('devtools')
library(MegaLMM)
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
here::i_am("analysis/MultiEnvironmentTrial_oat.Rmd")
```

```{r data}
# Importing Phenotype file (Leah complied in other scripts and added a copy to the shared directory)
multi_location_data <- read.csv(here("data","2023_2024_multi_location.csv"))

#list of accessions in alphabetical order
accessions_48 <- multi_location_data %>% 
  dplyr::select(germplasmName) %>% 
  arrange(germplasmName) %>% 
  unique()

# IL17-7339 and IL17-7334 are incredibly similar, combine observation data
# naming it IL17-733X

multi_location_data2 <- multi_location_data %>%
  mutate(germplasmName = ifelse(germplasmName %in% c("IL17-7334", "IL17-7339"), "IL17-733X", germplasmName))

#list of accessions in alphabetical order
accessions_47 <- multi_location_data2 %>% 
  dplyr::select(germplasmName) %>% 
  arrange(germplasmName) %>% 
  unique()

# GRM strait from t3, cool, but it looks like not all the accessions from Juan are on t3. we are missing 2 but we can move forward
GRM2 <- readRDS(here("data","oatGRM_47.rds")) # GRM made in ~/GitHub/Peter_2024_spring/Peter_2024_spring/scripts/Leah_BGLR_GMA.Rmd
GRM3 <- readRDS(here("data","oatGRM2_47.rds")) # GRM made in ~/GitHub/Peter_2024_spring/Peter_2024_spring/scripts/Leah_BGLR_GMA.Rmd ; added 0.0001 to the diagonal
```


```{r pheno_cleanup}
# use data from multi_location_data2 to make a table of observation data
grainWgt <- multi_location_data2 %>%
  mutate(oatYield = oat_yield) %>%
  mutate(peaYield = pea_yield) %>%
  mutate(total_grain = oat_yield + coalesce(pea_yield, 0))%>%
  mutate(peaAcc = peaName) %>%
  mutate(blockNumberF=as.factor(paste(studyYear, location, blockNumber))) %>% #block factor
  mutate(UniqEnv = paste0(studyLoc,studyYear))%>%
  mutate(UniqEnv_pea = paste0(peaAcc,'_',studyLoc,studyYear))%>%
  dplyr::select(blockNumberF, UniqEnv, UniqEnv_pea, peaAcc, studyYear, location, blockNumber,
         plotNumber, management, germplasmName, peaAcc, oatYield, peaYield, total_grain) 

# remove rows from the data file only if they have an NA value for both oat and pea yield
# NAs were messing with the ability to calculate the covariance matrix correctly
grainWgt <- grainWgt[!(is.na(grainWgt$oatYield) & is.na(grainWgt$peaYield)), ] 

#pth: the na's for the mono pea accession were causing error 
#Error in chol.default(S) : the leading minor of order 1 is not positive
#this fixed the error, but is it correct
grainWgt <- grainWgt %>% 
  mutate(peaAcc = if_else(is.na(peaAcc), "none", peaAcc))  

grainWgt$studyYear <- as.factor(grainWgt$studyYear)
grainWgt$location <- as.factor(grainWgt$location)
grainWgt$blockNumber <- as.factor(grainWgt$blockNumber)
grainWgt$UniqEnv <- as.factor(grainWgt$UniqEnv)

# try without monoculture plots
grainWgt2 <- grainWgt[grainWgt$management != "monoculture", ]
```

Create K matrix

```{r K, message=FALSE}
incOatAcc <- model.matrix(~ -1 + germplasmName, grainWgt)

#  use K = Z %*% GRM %*% t(Z),  Z is incidence matrix
K = incOatAcc %*% GRM2 %*% t(incOatAcc)

# try with the matrix with 0.001 added to the diagonal 
K2 = incOatAcc %*% GRM3 %*% t(incOatAcc)

```



Adaping from MegaLMM tutorial: https://github.com/deruncie/MegaLMM/blob/master/vignettes/MultiEnvironmentTrial.Rmd

```{r}
yield_data2 <- grainWgt2%>%dplyr::select(germplasmName, UniqEnv, UniqEnv_pea, peaAcc, oatYield)
yield_data2$UniqEnv <- as.character(yield_data2$UniqEnv)
yield_data2$UniqEnv_pea <- as.character(yield_data2$UniqEnv_pea)
yield_data2$Population <- NA
```

We can see the incidence matrix of lines by environments using the `Image` function in `MegaLMM`

```{r}
# Unique year, location
Image(as.matrix(table(yield_data2$germplasmName,yield_data2$UniqEnv))) + theme(legend.position = 'none') + xlab('Environment') + ylab('germplasmName')
# Unique year, location, pea ID
Image(as.matrix(table(yield_data2$germplasmName,yield_data2$UniqEnv_pea))) + theme(legend.position = 'none') + xlab('Environment') + ylab('germplasmName')
# Unique year, pea ID
Image(as.matrix(table(yield_data2$germplasmName,yield_data2$peaAcc))) + theme(legend.position = 'none') + xlab('Environment') + ylab('germplasmName')
```

```{r}
hist(table(yield_data2$germplasmName),main = 'Environments per line',breaks=20)
hist(table(yield_data2$UniqEnv),main = 'Lines per Environment',breaks=20)
hist(table(yield_data2$peaAcc),main = 'Lines per Environment',breaks=20)
```

MegaLMM works by each line having one value per environment 

```{r}
# mean value for oats that have multiple occurances with the same pea in the same location 
yield_data2_mean <- yield_data2 |>
  dplyr::summarise(
    oatYield = mean(oatYield, na.rm = TRUE),
    .by = c(germplasmName, Population, UniqEnv)
  )

yield_data2_mean <- yield_data2 |>
  dplyr::summarise(
    oatYield = mean(oatYield, na.rm = TRUE),
    .by = c(germplasmName, Population, peaAcc)
  )
```

We can view the matrix also using `Image`

```{r}
Image(GRM2)
```

## Formatting data from `MegaLMM`

The yield data was provided in the **tall** format, meaning a single observation per row. In this format we would say we have 1 trait (`Yield`) with values measured in many environments.

But `MegaLMM` isn't good for modeling GxE like this. Instead, we want to consider the yield in each environment as a separate trait, and each line is measured for 6-9 of these traits. So we need to construct a `502x19` trait matrix. The `MegaLMM` package includes a helper function to do this called `create_data_matrices`. This uses `tidyr`'s `pivot_wider` function to create the matrix, and the arguments are the same.

```{r}
data_matrices2 = create_data_matrices(
  tall_data = yield_data2_mean, # your input tall data.frame,
  id_cols = c('germplasmName','Population'), # vector giving the set of columns of tall_data used to identify each individual, and any covariates you'll want to use to model the trait data across individuals.
  names_from = 'UniqEnv_pea', # vector giving the set of columns of tall_data used to identify each trait 
  values_from = 'oatYield' # name of the trait data column
)

data_matrices2 = create_data_matrices(
  tall_data = yield_data2_mean, # your input tall data.frame,
  id_cols = c('germplasmName','Population'), # vector giving the set of columns of tall_data used to identify each individual, and any covariates you'll want to use to model the trait data across individuals.
  names_from = 'peaAcc', # vector giving the set of columns of tall_data used to identify each trait 
  values_from = 'oatYield' # name of the trait data column
)
```

The output of `create_data_matrices` is a list with 3 elements. We'll only use the first two.

The first is a new data.frame with one row per individual, and a single column giving the Line identifier. If you have covariates among lines (e.g. sex, population, etc), those variables should be included here too.

```{r}
sample_data2 = data_matrices2$data
sample_data2
```

The second is the `nxp` trait matrix. The rows of the trait matrix are aligned with the rows of the individual identifier data.frame. We can extract these for use in `MegaLMM`:

```{r}
Y2 = data_matrices2$Y
head(Y2)[,1:5]
```

One check we need to do is ensure all our individuals in our data are represented in the genomic relationship matrix:

```{r}
all(rownames(GRM2) %in% sample_data2$germplasmName)
GRM2 = GRM2[sample_data2$germplasmName,sample_data2$germplasmName]
```

# Set up Cross Validation

The goal of genomic prediction is to accurately predict the genetic values of individuals that are not observed in a particular environment. The standard way to estimate this accuracy is to mask a portion of the lines in the input data, use a model to predict these masked values, and then measure the correlation between the predicted values and the original data. In this tutorial we will do only 1 round of a k-fold cross-validation. Generally you would repeat this with other training / testing partition.

Because we are evaluating the accuracy for incomplete multi-environment trial prediction, we will mask different set of individuals in each environment, so each individual maintains input data in at least some individuals.

Because the individuals are stratified between two populations, we will ensure all testing individuals come from the same population. The masking algorithm will be:

1.  For each environment, decide which population is best represented
2.  For the observed individuals in that population, divide them into k-folds
3.  Create a matrix with the testing sets (fold_ID) for each observation

Not not worry about understanding this code! The call to `set.seed()` at the beginning makes it repeatable.

```{r}
#set.seed(1)
#k_fold = 5 # we will hold out 1/5 = 20% of the observations from each environment
#fold_ID_matrix = matrix(NA,nrow = nrow(Y),ncol = ncol(Y),dimnames = dimnames(Y))
#for(i in 1:ncol(fold_ID_matrix)) {
#  observed_lines = sample_data[!is.na(Y[,i]),]
#  pop = names(sort(table(observed_lines$Population),decreasing=T))[1]
#  observed_lines = subset(observed_lines,Population == pop)
#  n_lines = nrow(observed_lines)
#  observed_lines$fold = sample(rep(1:k_fold,(n_lines/k_fold)+1))[1:n_lines]
#  fold_ID_matrix[match(observed_lines$Line,rownames(fold_ID_matrix)),i] = observed_lines$fold
#}
```


# from JL : ~/DSFAS_Recommending/analysis/WashingtonSoftSpringWheatTrials.Rmd

##########
NY 2023

```{r}
yield_data3<-yield_data2%>%
  filter(UniqEnv == "NY2023")%>%
  dplyr::select(peaAcc, germplasmName, oatYield)

accNames <- yield_data3$germplasmName |> unique()
nAcc <- accNames |> length() # 47
trialNames <- yield_data3$peaAcc |> unique()
nTrials <- trialNames |> length() # 12

data_matrices <- MegaLMM::create_data_matrices(
  tall_data = yield_data3, # your input tall data.frame,
  id_cols = "germplasmName", # vector giving the set of columns of tall_data used to identify each individual, and any covariates you'll want to use to model the trait data across individuals.
  names_from = 'peaAcc', # vector giving the set of columns of tall_data used to identify each trait 
  values_from = 'oatYield' # name of the trait data column
)
sample_data <- data_matrices$data
yldWide <- data_matrices$Y
yldWide <- yldWide[, apply(yldWide, 2, 
                           function(v) sum(is.na(v)) < 0.95 * nrow(yldWide))]

```

#### Set up results objects

```{r Set up results objects}
nCVfolds <- 6
allLambdaPost <- NULL
allCorr <- tibble()

accNamesTib <- tibble(germplasmName=accNames)
seed <- 6234
set.seed(seed)
runID <- paste0("tempRunID", seed) # Will make a folder with this name
```

#### Run cross validation -- CV2
The idea here is, per trial, to leave N lines in the trial and predict the
remaining lines.  This is a case where we are predicting old accessions in 
old environments.
```{r Run cross validation -- CV2, eval=FALSE}
runID <- paste0("output/megaLMM/", runID, "CV2")
# Some cross val in each trial
#for (trialName in trialNames){
testTrials <- sample(trialNames, 12)
for (trialName in testTrials){
  for (cvFold in 1:nCVfolds){
    cat("####", which(testTrials == trialName), trialName, cvFold, "####", "\n")
    yldTrain <- yldWide
    yldTest <- yldWide
    nAccInTrial <- sum(!is.na(yldTrain[, trialName]))
    setMissing <- sample(nAccInTrial, size=nAccInTrial / 2 , replace=F)
    yldTrain[!is.na(yldTrain[, trialName]), trialName][setMissing] <- NA
    yldTest[which(!is.na(yldTest[, trialName]))[-setMissing], trialName] <- NA

    
    MegaLMM_state <- setupMegaLMMstate(accNames=accNamesTib, wideData=yldTrain,
                                       kinMat=GRM2, runID=runID) # try different things here for wideData

    # Burn in
    n_iter <- 200
    for (i in 1:6){
      cat(i)
      # Manually re-order from biggest to smallest
      MegaLMM_state <- reorder_factors(MegaLMM_state, drop_cor_threshold = 0.6)
      # Clear previous collected samples because we've re-started the chain 
      MegaLMM_state <- clear_Posterior(MegaLMM_state)
      # Draw n_iter new samples, storing the chain
      MegaLMM_state <- sample_MegaLMM(MegaLMM_state, n_iter, verbose=F)
    }
    cat("\n")
    MegaLMM_state <- clear_Posterior(MegaLMM_state)
    
    # Sampling
    n_iter = 2000
    MegaLMM_state <- sample_MegaLMM(MegaLMM_state, n_iter, verbose=F)
    MegaLMM_state <- save_posterior_chunk(MegaLMM_state)

    Lambda_samples = load_posterior_param(MegaLMM_state,'Lambda')
    Lambda_hat <- get_posterior_mean(Lambda_samples)
    U_samples = load_posterior_param(MegaLMM_state,'U_CV2')
    U_hat = get_posterior_mean(U_samples)
    Eta_mean = load_posterior_param(MegaLMM_state,'Eta_mean')
    
    obsYld <- yldWide[!is.na(yldWide[, trialName]), trialName][setMissing]
    predGen <- U_hat[!is.na(yldWide[, trialName]), trialName][setMissing]
    predPhen <- Eta_mean[!is.na(yldWide[, trialName]), trialName][setMissing]
    Uhat_accuracy <- cor(obsYld, predGen)
    Eta_mean_accuracy <- cor(obsYld, predPhen)
    
    allLambdaPost <- rbind(allLambdaPost, Lambda_hat)
    toAdd <- tibble(trial=trialName, accVec=list(names(obsYld)), 
                    genAcc=Uhat_accuracy, phenAcc=Eta_mean_accuracy)
    allCorr <- bind_rows(allCorr, toAdd)
  }#END CV
  saveRDS(list(allLambdaPost=allLambdaPost, allCorr=allCorr), 
          file=here::here("output", "megaLMM", paste0(seed, "MegaLMMresultsCV2.rds")))
}#END trial
```

summary of the MCMC chain 

```{r}
print(MegaLMM_state)
summary(MegaLMM_state)
```

Prediction Accuracy 

```{r}
MegaLMM_Uhat_accuracy = diag(cor(yldWide,U_hat,use='p')) 
MegaLMM_Uhat_accuracy
MegaLMM_Uhat_accuracy = diag(cor(yldTest,U_hat,use='p')) 
MegaLMM_Uhat_accuracy
# should this be the whole data set or the Test set (the ones masked in to train)
```

# Working with postierior samples

```{r}
dim(MegaLMM_state$Posterior$Lambda)
U = load_posterior_param(MegaLMM_state,'U_CV2')
# reload all parameters
MegaLMM_state$Posterior = reload_Posterior(MegaLMM_state)
dim(MegaLMM_state$Posterior$Lambda)
dim(MegaLMM_state$Posterior$F_h2)
# traceplot to check convergence
plot(U[,1,2],type='l')
traceplot_array(MegaLMM_state$Posterior$Lambda,facet_dim = 2,name = 'Lambda')
# summaries of the posterior samples
U_hat = get_posterior_mean(U)
dim(U_hat)
# calculate lower and upper 0.95 Highest Posterior Density bounds for each element of the matrix `U`
U_HPD = get_posterior_HPDinterval(U,prob = 0.95)
dim(U_HPD)
```

```{r}
# calculate functions of the parameters stored in the Posterior database
P_samples = get_posterior_FUN(MegaLMM_state,t(Lambda) %*% Lambda + diag(1/tot_Eta_prec[1,]))
dim(P_samples)
```

Extracting random effect covariances

extract the estimates and posterior distributions on the key variance-covariance parameters $\mathbf{G}$ and $\mathbf{R}$. The model for the genetic covariance in MegaLMM is: $\mathbf{G} = \mathbf{\Lambda^T \Sigma_{h^2_F} \Lambda} + \mathbf{\Psi \otimes \Sigma_{h^2_R}}$

```{r include=F}
#G_samples = get_posterior_FUN(MegaLMM_state,
#              t(Lambda) %*% diag(F_h2[1,]) %*% Lambda + diag(resid_h2[,1]/tot_Eta_prec[1,])
#            )
#dim(G_samples)
```
MegaLMM has functions to calculate these
```{r}
G_samples = load_posterior_param(MegaLMM_state,'G')
R_samples = load_posterior_param(MegaLMM_state,'R')
dim(G_samples)
dim(R_samples)
```

```{r}
rm(yield_data3,accNames,nAcc,trialNames,nTrials,data_matrices,sample_data,yldWide,accNamesTib,seed,runID,testTrials,MegaLMM_state,MegaLMM_Uhat_accuracy, U, U_hat, U_HPD, P_samples, G_samples, R_samples, yldTest, yldTrain, U_samples, Uhat_accuracy)
```






##########
NY 2024

```{r}
# I can only get MegaLMM::create_data_matrices to run if there is one value for a oat-pea combo. if that exact combo had more than one plot, the function dosn't like it. So using the mean of any duplicated combinations
yield_data3<-yield_data2%>%
  filter(UniqEnv == "NY2024")%>%
  dplyr::summarise(
    oatYield = mean(oatYield, na.rm = TRUE),
    .by = c(germplasmName, peaAcc))%>%
  dplyr::select(peaAcc, germplasmName, oatYield)

accNames <- yield_data3$germplasmName |> unique()
nAcc <- accNames |> length() # 47
trialNames <- yield_data3$peaAcc |> unique()
nTrials <- trialNames |> length() # 12

data_matrices <- MegaLMM::create_data_matrices(
  tall_data = yield_data3, # your input tall data.frame,
  id_cols = "germplasmName", # vector giving the set of columns of tall_data used to identify each individual, and any covariates you'll want to use to model the trait data across individuals.
  names_from = 'peaAcc', # vector giving the set of columns of tall_data used to identify each trait 
  values_from = 'oatYield' # name of the trait data column
)
sample_data <- data_matrices$data
yldWide <- data_matrices$Y
yldWide <- yldWide[, apply(yldWide, 2, 
                           function(v) sum(is.na(v)) < 0.95 * nrow(yldWide))]

```

#### Set up results objects

```{r Set up results objects}
nCVfolds <- 6
allLambdaPost <- NULL
allCorr <- tibble()

accNamesTib <- tibble(germplasmName=accNames)
seed <- 6234
set.seed(seed)
runID <- paste0("NY2024_", seed) # Will make a folder with this name
```

#### Run cross validation -- CV2
The idea here is, per trial, to leave N lines in the trial and predict the
remaining lines.  This is a case where we are predicting old accessions in 
old environments.
```{r Run cross validation -- CV2, eval=FALSE}
runID <- paste0("output/megaLMM/", runID, "CV2")
# Some cross val in each trial
#for (trialName in trialNames){
testTrials <- sample(trialNames, 12)
for (trialName in testTrials){
  for (cvFold in 1:nCVfolds){
    cat("####", which(testTrials == trialName), trialName, cvFold, "####", "\n")
    yldTrain <- yldWide
    yldTest <- yldWide
    nAccInTrial <- sum(!is.na(yldTrain[, trialName]))
    setMissing <- sample(nAccInTrial, size=nAccInTrial / 2 , replace=F)
    yldTrain[!is.na(yldTrain[, trialName]), trialName][setMissing] <- NA
    yldTest[which(!is.na(yldTest[, trialName]))[-setMissing], trialName] <- NA

    
    MegaLMM_state <- setupMegaLMMstate(accNames=accNamesTib, wideData=yldTrain,
                                       kinMat=GRM2, runID=runID) # try different things here for wideData

    # Burn in
    n_iter <- 200
    for (i in 1:6){
      cat(i)
      # Manually re-order from biggest to smallest
      MegaLMM_state <- reorder_factors(MegaLMM_state, drop_cor_threshold = 0.6)
      # Clear previous collected samples because we've re-started the chain 
      MegaLMM_state <- clear_Posterior(MegaLMM_state)
      # Draw n_iter new samples, storing the chain
      MegaLMM_state <- sample_MegaLMM(MegaLMM_state, n_iter, verbose=F)
    }
    cat("\n")
    MegaLMM_state <- clear_Posterior(MegaLMM_state)
    
    # Sampling
    n_iter = 2000
    MegaLMM_state <- sample_MegaLMM(MegaLMM_state, n_iter, verbose=F)
    MegaLMM_state <- save_posterior_chunk(MegaLMM_state)

    Lambda_samples = load_posterior_param(MegaLMM_state,'Lambda')
    Lambda_hat <- get_posterior_mean(Lambda_samples)
    U_samples = load_posterior_param(MegaLMM_state,'U_CV2')
    U_hat = get_posterior_mean(U_samples)
    Eta_mean = load_posterior_param(MegaLMM_state,'Eta_mean')
    
    obsYld <- yldWide[!is.na(yldWide[, trialName]), trialName][setMissing]
    predGen <- U_hat[!is.na(yldWide[, trialName]), trialName][setMissing]
    predPhen <- Eta_mean[!is.na(yldWide[, trialName]), trialName][setMissing]
    Uhat_accuracy <- cor(obsYld, predGen)
    Eta_mean_accuracy <- cor(obsYld, predPhen)
    
    allLambdaPost <- rbind(allLambdaPost, Lambda_hat)
    toAdd <- tibble(trial=trialName, accVec=list(names(obsYld)), 
                    genAcc=Uhat_accuracy, phenAcc=Eta_mean_accuracy)
    allCorr <- bind_rows(allCorr, toAdd)
  }#END CV
  saveRDS(list(allLambdaPost=allLambdaPost, allCorr=allCorr), 
          file=here::here("output", "megaLMM", paste0(seed, "MegaLMMresultsCV2.rds")))
}#END trial
```

summary of the MCMC chain 

```{r}
print(MegaLMM_state)
summary(MegaLMM_state)
```

Prediction Accuracy 

```{r}
MegaLMM_Uhat_accuracy = diag(cor(yldWide,U_hat,use='p')) 
MegaLMM_Uhat_accuracy
MegaLMM_Uhat_accuracy = diag(cor(yldTest,U_hat,use='p')) 
MegaLMM_Uhat_accuracy
# should this be the whole data set or the Test set (the ones masked in to train)
```


# Working with postierior samples

```{r}
dim(MegaLMM_state$Posterior$Lambda)
U = load_posterior_param(MegaLMM_state,'U_CV2')
# reload all parameters
MegaLMM_state$Posterior = reload_Posterior(MegaLMM_state)
dim(MegaLMM_state$Posterior$Lambda)
dim(MegaLMM_state$Posterior$F_h2)
# traceplot to check convergence
plot(U[,1,2],type='l')
traceplot_array(MegaLMM_state$Posterior$Lambda,facet_dim = 2,name = 'Lambda')
# summaries of the posterior samples
U_hat = get_posterior_mean(U)
dim(U_hat)
# calculate lower and upper 0.95 Highest Posterior Density bounds for each element of the matrix `U`
U_HPD = get_posterior_HPDinterval(U,prob = 0.95)
dim(U_HPD)
```

```{r}
# calculate functions of the parameters stored in the Posterior database
P_samples = get_posterior_FUN(MegaLMM_state,t(Lambda) %*% Lambda + diag(1/tot_Eta_prec[1,]))
dim(P_samples)
```

Extracting random effect covariances

extract the estimates and posterior distributions on the key variance-covariance parameters $\mathbf{G}$ and $\mathbf{R}$. The model for the genetic covariance in MegaLMM is: $\mathbf{G} = \mathbf{\Lambda^T \Sigma_{h^2_F} \Lambda} + \mathbf{\Psi \otimes \Sigma_{h^2_R}}$

```{r include=F}
#G_samples = get_posterior_FUN(MegaLMM_state,
#              t(Lambda) %*% diag(F_h2[1,]) %*% Lambda + diag(resid_h2[,1]/tot_Eta_prec[1,])
#            )
#dim(G_samples)
```
MegaLMM has functions to calculate these
```{r}
G_samples = load_posterior_param(MegaLMM_state,'G')
R_samples = load_posterior_param(MegaLMM_state,'R')
dim(G_samples)
dim(R_samples)
```

```{r}
rm(yield_data3,accNames,nAcc,trialNames,nTrials,data_matrices,sample_data,yldWide,accNamesTib,seed,runID,testTrials,MegaLMM_state,MegaLMM_Uhat_accuracy, U, U_hat, U_HPD, P_samples, G_samples, R_samples, yldTest, yldTrain, U_samples, Uhat_accuracy)
```




##########
IL 2023

```{r}
# I can only get MegaLMM::create_data_matrices to run if there is one value for a oat-pea combo. if that exact combo had more than one plot, the function dosn't like it. So using the mean of any duplicated combinations
yield_data3<-yield_data2%>%
  filter(UniqEnv == "IL2023")%>%
  dplyr::summarise(
    oatYield = mean(oatYield, na.rm = TRUE),
    .by = c(germplasmName, peaAcc))%>%
  dplyr::select(peaAcc, germplasmName, oatYield)

accNames <- yield_data3$germplasmName |> unique()
nAcc <- accNames |> length() # 47
trialNames <- yield_data3$peaAcc |> unique()
nTrials <- trialNames |> length() # 12

data_matrices <- MegaLMM::create_data_matrices(
  tall_data = yield_data3, # your input tall data.frame,
  id_cols = "germplasmName", # vector giving the set of columns of tall_data used to identify each individual, and any covariates you'll want to use to model the trait data across individuals.
  names_from = 'peaAcc', # vector giving the set of columns of tall_data used to identify each trait 
  values_from = 'oatYield' # name of the trait data column
)
sample_data <- data_matrices$data
yldWide <- data_matrices$Y
yldWide <- yldWide[, apply(yldWide, 2, 
                           function(v) sum(is.na(v)) < 0.95 * nrow(yldWide))]

```

#### Set up results objects

```{r Set up results objects}
nCVfolds <- 6
allLambdaPost <- NULL
allCorr <- tibble()

accNamesTib <- tibble(germplasmName=accNames)
seed <- 6234
set.seed(seed)
runID <- paste0("IL2023_", seed) # Will make a folder with this name
```

#### Run cross validation -- CV2
The idea here is, per trial, to leave N lines in the trial and predict the
remaining lines.  This is a case where we are predicting old accessions in 
old environments.
```{r Run cross validation -- CV2, eval=FALSE}
runID <- paste0("output/megaLMM/", runID, "CV2")
# Some cross val in each trial
#for (trialName in trialNames){
testTrials <- sample(trialNames, 12)
for (trialName in testTrials){
  for (cvFold in 1:nCVfolds){
    cat("####", which(testTrials == trialName), trialName, cvFold, "####", "\n")
    yldTrain <- yldWide
    yldTest <- yldWide
    nAccInTrial <- sum(!is.na(yldTrain[, trialName]))
    setMissing <- sample(nAccInTrial, size=nAccInTrial / 2 , replace=F)
    yldTrain[!is.na(yldTrain[, trialName]), trialName][setMissing] <- NA
    yldTest[which(!is.na(yldTest[, trialName]))[-setMissing], trialName] <- NA

    
    MegaLMM_state <- setupMegaLMMstate(accNames=accNamesTib, wideData=yldTrain,
                                       kinMat=GRM2, runID=runID) # try different things here for wideData

    # Burn in
    n_iter <- 200
    for (i in 1:6){
      cat(i)
      # Manually re-order from biggest to smallest
      MegaLMM_state <- reorder_factors(MegaLMM_state, drop_cor_threshold = 0.6)
      # Clear previous collected samples because we've re-started the chain 
      MegaLMM_state <- clear_Posterior(MegaLMM_state)
      # Draw n_iter new samples, storing the chain
      MegaLMM_state <- sample_MegaLMM(MegaLMM_state, n_iter, verbose=F)
    }
    cat("\n")
    MegaLMM_state <- clear_Posterior(MegaLMM_state)
    
    # Sampling
    n_iter = 2000
    MegaLMM_state <- sample_MegaLMM(MegaLMM_state, n_iter, verbose=F)
    MegaLMM_state <- save_posterior_chunk(MegaLMM_state)

    Lambda_samples = load_posterior_param(MegaLMM_state,'Lambda')
    Lambda_hat <- get_posterior_mean(Lambda_samples)
    U_samples = load_posterior_param(MegaLMM_state,'U_CV2')
    U_hat = get_posterior_mean(U_samples)
    Eta_mean = load_posterior_param(MegaLMM_state,'Eta_mean')
    
    obsYld <- yldWide[!is.na(yldWide[, trialName]), trialName][setMissing]
    predGen <- U_hat[!is.na(yldWide[, trialName]), trialName][setMissing]
    predPhen <- Eta_mean[!is.na(yldWide[, trialName]), trialName][setMissing]
    Uhat_accuracy <- cor(obsYld, predGen)
    Eta_mean_accuracy <- cor(obsYld, predPhen)
    
    allLambdaPost <- rbind(allLambdaPost, Lambda_hat)
    toAdd <- tibble(trial=trialName, accVec=list(names(obsYld)), 
                    genAcc=Uhat_accuracy, phenAcc=Eta_mean_accuracy)
    allCorr <- bind_rows(allCorr, toAdd)
  }#END CV
  saveRDS(list(allLambdaPost=allLambdaPost, allCorr=allCorr), 
          file=here::here("output", "megaLMM", paste0(seed, "IL2023_MegaLMMresultsCV2.rds")))
}#END trial
```

summary of the MCMC chain 

```{r}
print(MegaLMM_state)
summary(MegaLMM_state)
```

Prediction Accuracy 

```{r}
MegaLMM_Uhat_accuracy = diag(cor(yldWide,U_hat,use='p')) 
MegaLMM_Uhat_accuracy
MegaLMM_Uhat_accuracy = diag(cor(yldTest,U_hat,use='p')) 
MegaLMM_Uhat_accuracy
# should this be the whole data set or the Test set (the ones masked in to train)
```


# Working with postierior samples

```{r}
dim(MegaLMM_state$Posterior$Lambda)
U = load_posterior_param(MegaLMM_state,'U_CV2')
# reload all parameters
MegaLMM_state$Posterior = reload_Posterior(MegaLMM_state)
dim(MegaLMM_state$Posterior$Lambda)
dim(MegaLMM_state$Posterior$F_h2)
# traceplot to check convergence
plot(U[,1,2],type='l')
traceplot_array(MegaLMM_state$Posterior$Lambda,facet_dim = 2,name = 'Lambda')
# summaries of the posterior samples
U_hat = get_posterior_mean(U)
dim(U_hat)
# calculate lower and upper 0.95 Highest Posterior Density bounds for each element of the matrix `U`
U_HPD = get_posterior_HPDinterval(U,prob = 0.95)
dim(U_HPD)
```

```{r}
# calculate functions of the parameters stored in the Posterior database
P_samples = get_posterior_FUN(MegaLMM_state,t(Lambda) %*% Lambda + diag(1/tot_Eta_prec[1,]))
dim(P_samples)
```

Extracting random effect covariances

extract the estimates and posterior distributions on the key variance-covariance parameters $\mathbf{G}$ and $\mathbf{R}$. The model for the genetic covariance in MegaLMM is: $\mathbf{G} = \mathbf{\Lambda^T \Sigma_{h^2_F} \Lambda} + \mathbf{\Psi \otimes \Sigma_{h^2_R}}$

```{r include=F}
#G_samples = get_posterior_FUN(MegaLMM_state,
#              t(Lambda) %*% diag(F_h2[1,]) %*% Lambda + diag(resid_h2[,1]/tot_Eta_prec[1,])
#            )
#dim(G_samples)
```
MegaLMM has functions to calculate these
```{r}
G_samples = load_posterior_param(MegaLMM_state,'G')
R_samples = load_posterior_param(MegaLMM_state,'R')
dim(G_samples)
dim(R_samples)
```

```{r}
rm(yield_data3,accNames,nAcc,trialNames,nTrials,data_matrices,sample_data,yldWide,accNamesTib,seed,runID,testTrials,MegaLMM_state,MegaLMM_Uhat_accuracy, U, U_hat, U_HPD, P_samples, G_samples, R_samples, yldTest, yldTrain, U_samples, Uhat_accuracy)
```





##########
IL 2023

```{r}
# I can only get MegaLMM::create_data_matrices to run if there is one value for a oat-pea combo. if that exact combo had more than one plot, the function dosn't like it. So using the mean of any duplicated combinations
yield_data3<-yield_data2%>%
  filter(UniqEnv == "IL2024")%>%
  dplyr::summarise(
    oatYield = mean(oatYield, na.rm = TRUE),
    .by = c(germplasmName, peaAcc))%>%
  dplyr::select(peaAcc, germplasmName, oatYield)

accNames <- yield_data3$germplasmName |> unique()
nAcc <- accNames |> length() # 47
trialNames <- yield_data3$peaAcc |> unique()
nTrials <- trialNames |> length() # 12

data_matrices <- MegaLMM::create_data_matrices(
  tall_data = yield_data3, # your input tall data.frame,
  id_cols = "germplasmName", # vector giving the set of columns of tall_data used to identify each individual, and any covariates you'll want to use to model the trait data across individuals.
  names_from = 'peaAcc', # vector giving the set of columns of tall_data used to identify each trait 
  values_from = 'oatYield' # name of the trait data column
)
sample_data <- data_matrices$data
yldWide <- data_matrices$Y
yldWide <- yldWide[, apply(yldWide, 2, 
                           function(v) sum(is.na(v)) < 0.95 * nrow(yldWide))]

```

#### Set up results objects

```{r Set up results objects}
nCVfolds <- 6
allLambdaPost <- NULL
allCorr <- tibble()

accNamesTib <- tibble(germplasmName=accNames)
seed <- 6234
set.seed(seed)
runID <- paste0("IL2024_", seed) # Will make a folder with this name
```

#### Run cross validation -- CV2
The idea here is, per trial, to leave N lines in the trial and predict the
remaining lines.  This is a case where we are predicting old accessions in 
old environments.
```{r Run cross validation -- CV2, eval=FALSE}
runID <- paste0("output/megaLMM/", runID, "CV2")
# Some cross val in each trial
#for (trialName in trialNames){
testTrials <- sample(trialNames, 12)
for (trialName in testTrials){
  for (cvFold in 1:nCVfolds){
    cat("####", which(testTrials == trialName), trialName, cvFold, "####", "\n")
    yldTrain <- yldWide
    yldTest <- yldWide
    nAccInTrial <- sum(!is.na(yldTrain[, trialName]))
    setMissing <- sample(nAccInTrial, size=nAccInTrial / 2 , replace=F)
    yldTrain[!is.na(yldTrain[, trialName]), trialName][setMissing] <- NA
    yldTest[which(!is.na(yldTest[, trialName]))[-setMissing], trialName] <- NA

    
    MegaLMM_state <- setupMegaLMMstate(accNames=accNamesTib, wideData=yldTrain,
                                       kinMat=GRM2, runID=runID) # try different things here for wideData

    # Burn in
    n_iter <- 200
    for (i in 1:6){
      cat(i)
      # Manually re-order from biggest to smallest
      MegaLMM_state <- reorder_factors(MegaLMM_state, drop_cor_threshold = 0.6)
      # Clear previous collected samples because we've re-started the chain 
      MegaLMM_state <- clear_Posterior(MegaLMM_state)
      # Draw n_iter new samples, storing the chain
      MegaLMM_state <- sample_MegaLMM(MegaLMM_state, n_iter, verbose=F)
    }
    cat("\n")
    MegaLMM_state <- clear_Posterior(MegaLMM_state)
    
    # Sampling
    n_iter = 2000
    MegaLMM_state <- sample_MegaLMM(MegaLMM_state, n_iter, verbose=F)
    MegaLMM_state <- save_posterior_chunk(MegaLMM_state)

    Lambda_samples = load_posterior_param(MegaLMM_state,'Lambda')
    Lambda_hat <- get_posterior_mean(Lambda_samples)
    U_samples = load_posterior_param(MegaLMM_state,'U_CV2')
    U_hat = get_posterior_mean(U_samples)
    Eta_mean = load_posterior_param(MegaLMM_state,'Eta_mean')
    
    obsYld <- yldWide[!is.na(yldWide[, trialName]), trialName][setMissing]
    predGen <- U_hat[!is.na(yldWide[, trialName]), trialName][setMissing]
    predPhen <- Eta_mean[!is.na(yldWide[, trialName]), trialName][setMissing]
    Uhat_accuracy <- cor(obsYld, predGen)
    Eta_mean_accuracy <- cor(obsYld, predPhen)
    
    allLambdaPost <- rbind(allLambdaPost, Lambda_hat)
    toAdd <- tibble(trial=trialName, accVec=list(names(obsYld)), 
                    genAcc=Uhat_accuracy, phenAcc=Eta_mean_accuracy)
    allCorr <- bind_rows(allCorr, toAdd)
  }#END CV
  saveRDS(list(allLambdaPost=allLambdaPost, allCorr=allCorr), 
          file=here::here("output", "megaLMM", paste0(seed, "IL2024_MegaLMMresultsCV2.rds")))
}#END trial
```

summary of the MCMC chain 

```{r}
print(MegaLMM_state)
summary(MegaLMM_state)
```

Prediction Accuracy 

```{r}
MegaLMM_Uhat_accuracy = diag(cor(yldWide,U_hat,use='p')) 
MegaLMM_Uhat_accuracy
MegaLMM_Uhat_accuracy = diag(cor(yldTest,U_hat,use='p')) 
MegaLMM_Uhat_accuracy
# should this be the whole data set or the Test set (the ones masked in to train)
```


# Working with postierior samples

```{r}
dim(MegaLMM_state$Posterior$Lambda)
U = load_posterior_param(MegaLMM_state,'U_CV2')
# reload all parameters
MegaLMM_state$Posterior = reload_Posterior(MegaLMM_state)
dim(MegaLMM_state$Posterior$Lambda)
dim(MegaLMM_state$Posterior$F_h2)
# traceplot to check convergence
plot(U[,1,2],type='l')
traceplot_array(MegaLMM_state$Posterior$Lambda,facet_dim = 2,name = 'Lambda')
# summaries of the posterior samples
U_hat = get_posterior_mean(U)
dim(U_hat)
# calculate lower and upper 0.95 Highest Posterior Density bounds for each element of the matrix `U`
U_HPD = get_posterior_HPDinterval(U,prob = 0.95)
dim(U_HPD)
```

```{r}
# calculate functions of the parameters stored in the Posterior database
P_samples = get_posterior_FUN(MegaLMM_state,t(Lambda) %*% Lambda + diag(1/tot_Eta_prec[1,]))
dim(P_samples)
```

Extracting random effect covariances

extract the estimates and posterior distributions on the key variance-covariance parameters $\mathbf{G}$ and $\mathbf{R}$. The model for the genetic covariance in MegaLMM is: $\mathbf{G} = \mathbf{\Lambda^T \Sigma_{h^2_F} \Lambda} + \mathbf{\Psi \otimes \Sigma_{h^2_R}}$

```{r include=F}
#G_samples = get_posterior_FUN(MegaLMM_state,
#              t(Lambda) %*% diag(F_h2[1,]) %*% Lambda + diag(resid_h2[,1]/tot_Eta_prec[1,])
#            )
#dim(G_samples)
```
MegaLMM has functions to calculate these
```{r}
G_samples = load_posterior_param(MegaLMM_state,'G')
R_samples = load_posterior_param(MegaLMM_state,'R')
dim(G_samples)
dim(R_samples)
```

```{r}
rm(yield_data3,accNames,nAcc,trialNames,nTrials,data_matrices,sample_data,yldWide,accNamesTib,seed,runID,testTrials,MegaLMM_state,MegaLMM_Uhat_accuracy, U, U_hat, U_HPD, P_samples, G_samples, R_samples, yldTest, yldTrain, U_samples, Uhat_accuracy)
```





##########
SD 2023

```{r}
# I can only get MegaLMM::create_data_matrices to run if there is one value for a oat-pea combo. if that exact combo had more than one plot, the function dosn't like it. So using the mean of any duplicated combinations
yield_data3<-yield_data2%>%
  filter(UniqEnv == "SD2023")%>%
  dplyr::summarise(
    oatYield = mean(oatYield, na.rm = TRUE),
    .by = c(germplasmName, peaAcc))%>%
  dplyr::select(peaAcc, germplasmName, oatYield)

accNames <- yield_data3$germplasmName |> unique()
nAcc <- accNames |> length() # 47
trialNames <- yield_data3$peaAcc |> unique()
nTrials <- trialNames |> length() # 12

data_matrices <- MegaLMM::create_data_matrices(
  tall_data = yield_data3, # your input tall data.frame,
  id_cols = "germplasmName", # vector giving the set of columns of tall_data used to identify each individual, and any covariates you'll want to use to model the trait data across individuals.
  names_from = 'peaAcc', # vector giving the set of columns of tall_data used to identify each trait 
  values_from = 'oatYield' # name of the trait data column
)
sample_data <- data_matrices$data
yldWide <- data_matrices$Y
yldWide <- yldWide[, apply(yldWide, 2, 
                           function(v) sum(is.na(v)) < 0.95 * nrow(yldWide))]

```

#### Set up results objects

```{r Set up results objects}
nCVfolds <- 6
allLambdaPost <- NULL
allCorr <- tibble()

accNamesTib <- tibble(germplasmName=accNames)
seed <- 6234
set.seed(seed)
runID <- paste0("SD2023_", seed) # Will make a folder with this name
```

#### Run cross validation -- CV2
The idea here is, per trial, to leave N lines in the trial and predict the
remaining lines.  This is a case where we are predicting old accessions in 
old environments.
```{r Run cross validation -- CV2, eval=FALSE}
runID <- paste0("output/megaLMM/", runID, "CV2")
# Some cross val in each trial
#for (trialName in trialNames){
testTrials <- sample(trialNames, 12)
for (trialName in testTrials){
  for (cvFold in 1:nCVfolds){
    cat("####", which(testTrials == trialName), trialName, cvFold, "####", "\n")
    yldTrain <- yldWide
    yldTest <- yldWide
    nAccInTrial <- sum(!is.na(yldTrain[, trialName]))
    setMissing <- sample(nAccInTrial, size=nAccInTrial / 2 , replace=F)
    yldTrain[!is.na(yldTrain[, trialName]), trialName][setMissing] <- NA
    yldTest[which(!is.na(yldTest[, trialName]))[-setMissing], trialName] <- NA

    
    MegaLMM_state <- setupMegaLMMstate(accNames=accNamesTib, wideData=yldTrain,
                                       kinMat=GRM2, runID=runID) # try different things here for wideData

    # Burn in
    n_iter <- 200
    for (i in 1:6){
      cat(i)
      # Manually re-order from biggest to smallest
      MegaLMM_state <- reorder_factors(MegaLMM_state, drop_cor_threshold = 0.6)
      # Clear previous collected samples because we've re-started the chain 
      MegaLMM_state <- clear_Posterior(MegaLMM_state)
      # Draw n_iter new samples, storing the chain
      MegaLMM_state <- sample_MegaLMM(MegaLMM_state, n_iter, verbose=F)
    }
    cat("\n")
    MegaLMM_state <- clear_Posterior(MegaLMM_state)
    
    # Sampling
    n_iter = 2000
    MegaLMM_state <- sample_MegaLMM(MegaLMM_state, n_iter, verbose=F)
    MegaLMM_state <- save_posterior_chunk(MegaLMM_state)

    Lambda_samples = load_posterior_param(MegaLMM_state,'Lambda')
    Lambda_hat <- get_posterior_mean(Lambda_samples)
    U_samples = load_posterior_param(MegaLMM_state,'U_CV2')
    U_hat = get_posterior_mean(U_samples)
    Eta_mean = load_posterior_param(MegaLMM_state,'Eta_mean')
    
    obsYld <- yldWide[!is.na(yldWide[, trialName]), trialName][setMissing]
    predGen <- U_hat[!is.na(yldWide[, trialName]), trialName][setMissing]
    predPhen <- Eta_mean[!is.na(yldWide[, trialName]), trialName][setMissing]
    Uhat_accuracy <- cor(obsYld, predGen)
    Eta_mean_accuracy <- cor(obsYld, predPhen)
    
    allLambdaPost <- rbind(allLambdaPost, Lambda_hat)
    toAdd <- tibble(trial=trialName, accVec=list(names(obsYld)), 
                    genAcc=Uhat_accuracy, phenAcc=Eta_mean_accuracy)
    allCorr <- bind_rows(allCorr, toAdd)
  }#END CV
  saveRDS(list(allLambdaPost=allLambdaPost, allCorr=allCorr), 
          file=here::here("output", "megaLMM", paste0(seed, "SD2023_MegaLMMresultsCV2.rds")))
}#END trial
```

summary of the MCMC chain 

```{r}
print(MegaLMM_state)
summary(MegaLMM_state)
```

Prediction Accuracy 

```{r}
MegaLMM_Uhat_accuracy = diag(cor(yldWide,U_hat,use='p')) 
MegaLMM_Uhat_accuracy
MegaLMM_Uhat_accuracy = diag(cor(yldTest,U_hat,use='p')) 
MegaLMM_Uhat_accuracy
# should this be the whole data set or the Test set (the ones masked in to train)
```


# Working with postierior samples

```{r}
dim(MegaLMM_state$Posterior$Lambda)
U = load_posterior_param(MegaLMM_state,'U_CV2')
# reload all parameters
MegaLMM_state$Posterior = reload_Posterior(MegaLMM_state)
dim(MegaLMM_state$Posterior$Lambda)
dim(MegaLMM_state$Posterior$F_h2)
# traceplot to check convergence
plot(U[,1,2],type='l')
traceplot_array(MegaLMM_state$Posterior$Lambda,facet_dim = 2,name = 'Lambda')
# summaries of the posterior samples
U_hat = get_posterior_mean(U)
dim(U_hat)
# calculate lower and upper 0.95 Highest Posterior Density bounds for each element of the matrix `U`
U_HPD = get_posterior_HPDinterval(U,prob = 0.95)
dim(U_HPD)
```

```{r}
# calculate functions of the parameters stored in the Posterior database
P_samples = get_posterior_FUN(MegaLMM_state,t(Lambda) %*% Lambda + diag(1/tot_Eta_prec[1,]))
dim(P_samples)
```

Extracting random effect covariances

extract the estimates and posterior distributions on the key variance-covariance parameters $\mathbf{G}$ and $\mathbf{R}$. The model for the genetic covariance in MegaLMM is: $\mathbf{G} = \mathbf{\Lambda^T \Sigma_{h^2_F} \Lambda} + \mathbf{\Psi \otimes \Sigma_{h^2_R}}$

```{r include=F}
#G_samples = get_posterior_FUN(MegaLMM_state,
#              t(Lambda) %*% diag(F_h2[1,]) %*% Lambda + diag(resid_h2[,1]/tot_Eta_prec[1,])
#            )
#dim(G_samples)
```
MegaLMM has functions to calculate these
```{r}
G_samples = load_posterior_param(MegaLMM_state,'G')
R_samples = load_posterior_param(MegaLMM_state,'R')
dim(G_samples)
dim(R_samples)
```

```{r}
rm(yield_data3,accNames,nAcc,trialNames,nTrials,data_matrices,sample_data,yldWide,accNamesTib,seed,runID,testTrials,MegaLMM_state,MegaLMM_Uhat_accuracy, U, U_hat, U_HPD, P_samples, G_samples, R_samples, yldTest, yldTrain, U_samples, Uhat_accuracy)
```





##########
SD 2024

```{r}
# I can only get MegaLMM::create_data_matrices to run if there is one value for a oat-pea combo. if that exact combo had more than one plot, the function dosn't like it. So using the mean of any duplicated combinations
yield_data3<-yield_data2%>%
  filter(UniqEnv == "SD2024")%>%
  dplyr::summarise(
    oatYield = mean(oatYield, na.rm = TRUE),
    .by = c(germplasmName, peaAcc))%>%
  dplyr::select(peaAcc, germplasmName, oatYield)

accNames <- yield_data3$germplasmName |> unique()
nAcc <- accNames |> length() # 47
trialNames <- yield_data3$peaAcc |> unique()
nTrials <- trialNames |> length() # 12

data_matrices <- MegaLMM::create_data_matrices(
  tall_data = yield_data3, # your input tall data.frame,
  id_cols = "germplasmName", # vector giving the set of columns of tall_data used to identify each individual, and any covariates you'll want to use to model the trait data across individuals.
  names_from = 'peaAcc', # vector giving the set of columns of tall_data used to identify each trait 
  values_from = 'oatYield' # name of the trait data column
)
sample_data <- data_matrices$data
yldWide <- data_matrices$Y
yldWide <- yldWide[, apply(yldWide, 2, 
                           function(v) sum(is.na(v)) < 0.95 * nrow(yldWide))]

```

#### Set up results objects

```{r Set up results objects}
nCVfolds <- 6
allLambdaPost <- NULL
allCorr <- tibble()

accNamesTib <- tibble(germplasmName=accNames)
seed <- 6234
set.seed(seed)
runID <- paste0("SD2024_", seed) # Will make a folder with this name
```

#### Run cross validation -- CV2
The idea here is, per trial, to leave N lines in the trial and predict the
remaining lines.  This is a case where we are predicting old accessions in 
old environments.
```{r Run cross validation -- CV2, eval=FALSE}
runID <- paste0("output/megaLMM/", runID, "CV2")
# Some cross val in each trial
#for (trialName in trialNames){
testTrials <- sample(trialNames, 12)
for (trialName in testTrials){
  for (cvFold in 1:nCVfolds){
    cat("####", which(testTrials == trialName), trialName, cvFold, "####", "\n")
    yldTrain <- yldWide
    yldTest <- yldWide
    nAccInTrial <- sum(!is.na(yldTrain[, trialName]))
    setMissing <- sample(nAccInTrial, size=nAccInTrial / 2 , replace=F)
    yldTrain[!is.na(yldTrain[, trialName]), trialName][setMissing] <- NA
    yldTest[which(!is.na(yldTest[, trialName]))[-setMissing], trialName] <- NA

    
    MegaLMM_state <- setupMegaLMMstate(accNames=accNamesTib, wideData=yldTrain,
                                       kinMat=GRM2, runID=runID) # try different things here for wideData

    # Burn in
    n_iter <- 200
    for (i in 1:6){
      cat(i)
      # Manually re-order from biggest to smallest
      MegaLMM_state <- reorder_factors(MegaLMM_state, drop_cor_threshold = 0.6)
      # Clear previous collected samples because we've re-started the chain 
      MegaLMM_state <- clear_Posterior(MegaLMM_state)
      # Draw n_iter new samples, storing the chain
      MegaLMM_state <- sample_MegaLMM(MegaLMM_state, n_iter, verbose=F)
    }
    cat("\n")
    MegaLMM_state <- clear_Posterior(MegaLMM_state)
    
    # Sampling
    n_iter = 2000
    MegaLMM_state <- sample_MegaLMM(MegaLMM_state, n_iter, verbose=F)
    MegaLMM_state <- save_posterior_chunk(MegaLMM_state)

    Lambda_samples = load_posterior_param(MegaLMM_state,'Lambda')
    Lambda_hat <- get_posterior_mean(Lambda_samples)
    U_samples = load_posterior_param(MegaLMM_state,'U_CV2')
    U_hat = get_posterior_mean(U_samples)
    Eta_mean = load_posterior_param(MegaLMM_state,'Eta_mean')
    
    obsYld <- yldWide[!is.na(yldWide[, trialName]), trialName][setMissing]
    predGen <- U_hat[!is.na(yldWide[, trialName]), trialName][setMissing]
    predPhen <- Eta_mean[!is.na(yldWide[, trialName]), trialName][setMissing]
    Uhat_accuracy <- cor(obsYld, predGen)
    Eta_mean_accuracy <- cor(obsYld, predPhen)
    
    allLambdaPost <- rbind(allLambdaPost, Lambda_hat)
    toAdd <- tibble(trial=trialName, accVec=list(names(obsYld)), 
                    genAcc=Uhat_accuracy, phenAcc=Eta_mean_accuracy)
    allCorr <- bind_rows(allCorr, toAdd)
  }#END CV
  saveRDS(list(allLambdaPost=allLambdaPost, allCorr=allCorr), 
          file=here::here("output", "megaLMM", paste0(seed, "SD2024_MegaLMMresultsCV2.rds")))
}#END trial
```

summary of the MCMC chain 

```{r}
print(MegaLMM_state)
summary(MegaLMM_state)
```

Prediction Accuracy 

```{r}
MegaLMM_Uhat_accuracy = diag(cor(yldWide,U_hat,use='p')) 
MegaLMM_Uhat_accuracy
MegaLMM_Uhat_accuracy = diag(cor(yldTest,U_hat,use='p')) 
MegaLMM_Uhat_accuracy
# should this be the whole data set or the Test set (the ones masked in to train)
```


# Working with postierior samples

```{r}
dim(MegaLMM_state$Posterior$Lambda)
U = load_posterior_param(MegaLMM_state,'U_CV2')
# reload all parameters
MegaLMM_state$Posterior = reload_Posterior(MegaLMM_state)
dim(MegaLMM_state$Posterior$Lambda)
dim(MegaLMM_state$Posterior$F_h2)
# traceplot to check convergence
plot(U[,1,2],type='l')
traceplot_array(MegaLMM_state$Posterior$Lambda,facet_dim = 2,name = 'Lambda')
# summaries of the posterior samples
U_hat = get_posterior_mean(U)
dim(U_hat)
# calculate lower and upper 0.95 Highest Posterior Density bounds for each element of the matrix `U`
U_HPD = get_posterior_HPDinterval(U,prob = 0.95)
dim(U_HPD)
```

```{r}
# calculate functions of the parameters stored in the Posterior database
P_samples = get_posterior_FUN(MegaLMM_state,t(Lambda) %*% Lambda + diag(1/tot_Eta_prec[1,]))
dim(P_samples)
```

Extracting random effect covariances

extract the estimates and posterior distributions on the key variance-covariance parameters $\mathbf{G}$ and $\mathbf{R}$. The model for the genetic covariance in MegaLMM is: $\mathbf{G} = \mathbf{\Lambda^T \Sigma_{h^2_F} \Lambda} + \mathbf{\Psi \otimes \Sigma_{h^2_R}}$

```{r include=F}
#G_samples = get_posterior_FUN(MegaLMM_state,
#              t(Lambda) %*% diag(F_h2[1,]) %*% Lambda + diag(resid_h2[,1]/tot_Eta_prec[1,])
#            )
#dim(G_samples)
```
MegaLMM has functions to calculate these
```{r}
G_samples = load_posterior_param(MegaLMM_state,'G')
R_samples = load_posterior_param(MegaLMM_state,'R')
dim(G_samples)
dim(R_samples)
```

```{r}
rm(yield_data3,accNames,nAcc,trialNames,nTrials,data_matrices,sample_data,yldWide,accNamesTib,seed,runID,testTrials,MegaLMM_state,MegaLMM_Uhat_accuracy, U, U_hat, U_HPD, P_samples, G_samples, R_samples, yldTest, yldTrain, U_samples, Uhat_accuracy)
```
